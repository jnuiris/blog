<h3>Ajax学习笔记</h3>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21-3-12
<hr>
<p>虽然目前Fetch和Axios比较流行，但是不把原生Ajax弄明白总觉得心里面有点膈应，加油。</p>
<h3>1.Ajax概述</h3>
<p>
传统网站中存在的问题:
<ul>
<li>网速慢得情况下，页面加载时间长，用户只能等待</li>
<li>表单提交后，如果一项内容不合格，需要重新填写所有表单内容</li>
<li>页面跳转，重新加载页面，造成资源浪费，增加用户等待时间</li>
</ul>
</p>
<p>
Ajax概述:
浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。（实现局部更新)
</p>
<p>
Ajax的应用场景:
<ol>
<li>页面上拉加载更多数据</li>
<li>列表数据无刷新分页</li>
<li>表单项离开焦点数据验证</li>
<li>搜索框提示文字下拉列表</li>
</ol>
</p>
<p>

</p>
<h3>2.Ajax原理</h3>
<p>
在传统的网站应用中，都是浏览器端直接跟服务器端交互数据，由于浏览器在浏览网站时不能再响应其他数据，因此必须刷新。Ajax是浏览器的代理人，Ajax帮助浏览器请求和响应服务器端数据。在传统的网站应用中过程是不可控的，但是使用Ajax是可控的。
<br>
<br>
Ajax的实现步骤:
<ol>
<li>创建Ajax对象:
<pre>
<code>
var xhr = new XMLHttpRequest();
</code>
</pre>
</li>
<li>
告诉Ajax请求地址以及请求方式
<pre>
<code>
xhr.open('get', 'http://www.example.com')
</code>
</pre>
</li>
<li>
发送请求
<pre>
<code>
xhr.send();
</code>
</pre>
</li>
<li>
<pre>
<code>
xhr.onload = function() {
    console.log(xhr.responseText);
}
</code>
</pre>
</li>
</ol>
</p>
<h3>3.Ajax的实现步骤</h3>
<p>
直接看代码，样例如下:
<pre>
<code>
//  引入express框架
const express = require('express');
//  路径处理模块
const path = require('path');
//  创建web服务器
const app = express();
//  静态资源访问服务功能
app.use(express.static(path.join(__dirname, 'public')));
app.get('/first', (req, res) => {
    res.send('Hello Ajax');
})
//  监听端口
app.listen(3000);
//  控制台提示输出
console.log('服务器启动成功');
</code>
</pre>
</p>
<p>
一般情况下服务器端不会返回字符串形式的数据，大多数情况下都会返回JSON形式的数据，然后和HTML拼接，下面是实现的示例代码:
<pre>
<code>
后台:
app.get('/test2', (req, res) => {
    //  res.send可以返回一个JSON对象
    res.send({'name': 'zs'});
})
</code>
<code>
前端:
//  1.创建Ajax对象
    let xhr = new XMLHttpRequest();
    //  2.告诉Ajax对象向哪发送请求，以什么方式发送请求
    //  open方法的参数第一个是请求方式，第二个是请求地址
    xhr.open('get', 'http://localhost:3000/test2');
    //  3.发送请求
    xhr.send();
    //  4.获取服务器端响应到客户端的数据
    //  onload在Ajax在接受服务器端的响应之后再触发
    // xhr.onload(function () {
    //     console.log(xhr.responseText);
    // })
    xhr.onload = function () {
        // console.log(xhr.responseText);
        var responseText = JSON.parse(xhr.responseText);
        console.log(typeof responseText.name);
        // console.log(JSON.parse(responseText));
        var str = '<h2>' + responseText.name + '</h2>';
        document.body.innerHTML = str;
    }
</code>
</pre>
但是在http请求中，不管是请求数据，还是响应数据，最终都会被转换成字符串类型。因此需要使用JSON.parse方法将字符串转换为JSON对象。
<br>
需要注意的是:直接在浏览器地址栏:localhost:3000/接口，会直接返回后台数据，要想返回客户端处理后的结果，必须使用localhost:3000/..html。
</p>
<h3>
4.Ajax传递请求参数
</h3>
<p>在传统网站中，请求参数是通过表单传递的，get请求放在请求参数之中，post请求放在请求体之中，在Ajax请求中，我们需要自己定义请求参数。</p>
<p>
get请求参数的示例代码:
<pre>
<b>后端:</b>
<code>
app.get('/test3', (req, res) => {
    res.send(req.query);
})
</code>
<b>前端</b>
<code>
&lt;p&gt;
    名字:&lt;input type="text" name="" id="username"&gt;
&lt;/p&gt;
&lt;p&gt;
    年龄:&lt;input type="text" name="" id="age"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;input type="button" value="提交" id="btn"&gt;
&lt;/p&gt;
&lt;script&gt;
    var btn = document.getElementById('btn');
    var xhr = new XMLHttpRequest();
    var username = document.getElementById('username');
    var age = document.getElementById('age');
    btn.onclick = function () {
        var nameValue = username.value;
        var ageValue = age.value;
        var params = 'username=' + nameValue + '&age=' + ageValue;
        xhr.open('get', 'http://localhost:3000/test3?' + params);
        xhr.send();
        xhr.onload = function () {
            console.log(xhr.responseText);
        }
    }
&lt;/script&gt;
</code>
</pre>
</p>
<p>
POST请求参数必须放在请求体中，且必须指定请求参数的类型，我们用send方法来实现POST请求。
<p>报文回顾:在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵循规定好的格式。分为报文头和报文体，报文头存储键值对，报文体存储内容（必须post请求参数)。</p>
示例代码如下:
<pre>
<code>
&lt;p&gt;
    名字:&lt;input type="text" name="" id="username"&gt;
&lt;/p&gt;
&lt;p&gt;
    年龄:&lt;input type="text" name="" id="age"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;input type="button" value="提交" id="btn"&gt;
&lt;/p&gt;
&lt;script&gt;
    var btn = document.getElementById('btn');
    var xhr = new XMLHttpRequest();
    var username = document.getElementById('username');
    var age = document.getElementById('age');
    btn.onclick = function () {
        var nameValue = username.value;
        var ageValue = age.value;
        var params = 'username=' + nameValue + '&age=' + ageValue;
        xhr.open('post', 'http://localhost:3000/test4');
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        xhr.send(params);
        xhr.onload = function () {
            console.log(xhr.responseText);
        }
    }
&lt;/script&gt;
</code>
</pre>
但是这里我无法复现。最终发现加入以下代码后就可以用了:
<pre>
<code>
app.use(bodyParser.urlencoded({
    extended: true
}));
</code>
</pre>
</p>
<p>
使用JSON发送Ajax请求。
<pre>
<code>
&lt;script&gt;
    var xhr = new XMLHttpRequest();
    xhr.open('post', 'http://localhost:3000/json');
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(JSON.stringify({'name': 'zhangsan', age: 20}));
    xhr.onload = function () {
        console.log(xhr.responseText);
    }
&lt;/script&gt;
</code>
</pre>
get请求是不能提交Json数据格式的，传统网站的表单也不支持Json数据格式。
</p>
<p>
一种过时的获取服务器端响应的方式，先了解一下Ajax状态码:
<ul>
<li>0:请求未初始化（还没有调用open())</li>
<li>1:请求已经建立，但是还没有发送（还没有调用send())</li>
<li>2.请求已经发送</li>
<li>3.请求正在处理中，通常响应中已经有部分数据可以用了</li>
<li>4.响应已经完成，可以获取并使用服务器的响应了</li>
</ul>
</p>
<p>
通过<pre><code>xhr.readyState</code></pre>可以获取Ajax的响应状态码。
</p>
<p>
<pre><code>onreadystatechange</code></pre>事件中可以输出readyState。
</p>
<p>
onload事件是不兼容IE低版本浏览器的，但是onreadystatechange事件是兼容的，onreadystatechange事件基本已经被淘汰了，示例代码如下:
<pre>
<code>
var xhr = new XMLHttpRequest();
    console.log(xhr.readyState);
    xhr.open('get', 'http://localhost:3000/readyState');
    console.log(xhr.readyState);
    xhr.onreadystatechange = function () {
        //  2:请求已经发送
        //  3:已经接收到服务器端的部分数据了
        //  4:服务器端的响应数据已经接收完成
        console.log(xhr.readyState);
        //  对ajax状态码进行判断，如果状态码的值为4，可以接收数据了
        if(xhr.readyState == 4) {
            console.log(xhr.responseText);
        }
    }
    xhr.send();
</code>
</pre>
</p>
<p>Ajax错误处理</p>
<p>
错误处理的类型:
<ol>
<li>网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。可以判断服务器端返回的状态码，分别进行处理。xhr.status获取http状态码。示例代码如下:
<pre>
<code>
var btn = document.getElementById('btn');
    btn.onclick = function () {
        var xhr = new XMLHttpRequest();
        xhr.open('get', 'http://localhost:3000/error');
        xhr.send();
        xhr.onload = function () {
            console.log(xhr.responseText);
            // console.log(xhr.status);
            if(xhr.status == 400) {
                alert('请求出错');
            }
        }
    }
</code>
</pre>
</li>
<li>
网络畅通，服务器端没有接收到请求，返回404状态码。示例代码如下:直接把请求地址写错就行了。
<pre>
<code>
var btn = document.getElementById('btn');
    btn.onclick = function () {
        var xhr = new XMLHttpRequest();
        xhr.open('get', 'http://localhost:3000/error123');
        xhr.send();
        xhr.onload = function () {
            console.log(xhr.responseText);
            // console.log(xhr.status);
            if(xhr.status == 400) {
                alert('请求出错');
            }
        }
    }
</code>
</pre>
</li>
<li>
网络畅通，服务器端能接收到请求，服务器端返回500状态码。直接在后端代码中加一个不存在的变量就可以模拟。
<pre>
<code>
app.get('/error', (req, res) => {
    console.log(abc);
    res.status(400).send('not ok');
})
</code>
</pre>
</li>
<li>
网络中断，请求无法发送到服务器端。
<br>
这种情况会触发xhr对象下面的onerror事件，在onerror事件处理函数中可以对错误进行处理。
<pre>
<code>
 var btn = document.getElementById('btn');
    btn.onclick = function () {
        var xhr = new XMLHttpRequest();
        xhr.open('get', 'http://localhost:3000/error');
        xhr.send();
        xhr.onload = function () {
            console.log(xhr.responseText);
            // console.log(xhr.status);
            if(xhr.status == 400) {
                alert('请求出错');
            }
        }
        xhr.onerror = function () {
            console.log('网络中断，无法发送Ajax请求')
        }
    }
    // Ajax状态码: 表示Ajax请求的过程状态 ajax对象返回的
    // Http状态码: 表示请求的处理结果 是服务器端返回的
</code>
</pre>
</li>
</ol>
</p>
<p>
低版本IE浏览器的缓存问题:在低版本的IT浏览器中，Ajax请求有严重的缓存问题，即在请求地址不发生变化的情况下，只有第一次请求会真正发送到服务器端，后续的请求都会从浏览器的缓存中获取结果。即使服务器端的数据更新了，客户端依然拿到的是缓存中的旧数据。
<br>
<p>解决方案；保证每一次的请求地址都不一样就可以了，可以为请求地址添加请求参数，示例代码:</p>
<pre>
<code>
 var btn = document.getElementById('btn');
    btn.onclick = function () {
        var xhr = new XMLHttpRequest();
        xhr.open('get', 'http://localhost:3000/cache?t=' + Math.random());
        xhr.send();
        xhr.onreadystatechange = function () {
            if(xhr.readyState == 4 && xhr.status == 200) {
                alert(xhr.responseText);
            }
        }
    }
</code>
</pre>
</p>
