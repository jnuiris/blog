#JS异步编程
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>21-3-7
<hr>
<h3>1.异步编程简述和回调地狱</h3>
<p>Javascript的执行环境是单线程，JS引擎中负责解释和执行Javascript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完才能执行下一个，会阻塞其他任务，这个任务可称为主线程</p>
<p>
异步模型可以一起执行多个任务，JS中常见的异步调用有:
<ul>
<li>定时任务</li>
<li>Ajax</li>
<li>事件函数</li>
</ul>
</p>
<p>
以一个简单的Ajax程序为例:
<br>
<pre>
$.ajax({
        url: 'http://localhost:3000/data',
        success: function (data) {
            console.log(data);
        }
    });
    $.ajax({
        url: 'http://localhost:3000/data1',
        success: function (data) {
            console.log(data);
        }
    });
    $.ajax({
        url: 'http://localhost:3000/data2',
        success: function (data) {
            console.log(data);
        }
    });
</pre>
</p>
<p>
假如后端data,data1,data2的数据分别是one, two, three，在浏览器中刷新，未必总是会按照data,data1,dat2的顺序打印，（尤其是在后端添加定时器之后），要使得程序总是按照data,data1,data2的顺序打印，必须写成下面这种嵌套（回调函数）的形式。
</p>
<br>
<pre>
$.ajax({
        url: 'http://localhost:3000/data',
        success: function (data) {
            console.log(data);
            $.ajax({
                url: 'http://localhost:3000/data1',
                success: function (data) {
                    console.log(data);
                    $.ajax({
                        url: 'http://localhost:3000/data2',
                        success: function (data) {
                            console.log(data);
                        }
                    });
                }
            });
        }
    });
</pre>
<p>
当嵌套的层数过多时，便会形成“回调地狱”的问题，可读性非常差，因此ES6引入了Promise API。
</p>
<h3>
2.Promise的使用
</h3>
<p>
前面已经简单描述了什么是异步编程和回调地狱，Promise就是为了解决回调地狱的问题而诞生的，Promise的特性如下:
<ul>
<li>主要解决异步深层嵌套的问题</li>
<li>Promise提供了简洁的API使得异步操作更加容易</li>
</ul>
</p>
