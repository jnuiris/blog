#JS异步编程
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>21-3-7
<hr>
<h3>1.异步编程简述和回调地狱</h3>
<p>Javascript的执行环境是单线程，JS引擎中负责解释和执行Javascript代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完才能执行下一个，会阻塞其他任务，这个任务可称为主线程</p>
<p>
异步模型可以一起执行多个任务，JS中常见的异步调用有:
<ul>
<li>定时任务</li>
<li>Ajax</li>
<li>事件函数</li>
</ul>
</p>
<p>
以一个简单的Ajax程序为例:
<br>
<pre>
$.ajax({
        url: 'http://localhost:3000/data',
        success: function (data) {
            console.log(data);
        }
    });
    $.ajax({
        url: 'http://localhost:3000/data1',
        success: function (data) {
            console.log(data);
        }
    });
    $.ajax({
        url: 'http://localhost:3000/data2',
        success: function (data) {
            console.log(data);
        }
    });
</pre>
</p>
<p>
假如后端data,data1,data2的数据分别是one, two, three，在浏览器中刷新，未必总是会按照data,data1,dat2的顺序打印，（尤其是在后端添加定时器之后），要使得程序总是按照data,data1,data2的顺序打印，必须写成下面这种嵌套（回调函数）的形式。
</p>
<br>
<pre>
$.ajax({
        url: 'http://localhost:3000/data',
        success: function (data) {
            console.log(data);
            $.ajax({
                url: 'http://localhost:3000/data1',
                success: function (data) {
                    console.log(data);
                    $.ajax({
                        url: 'http://localhost:3000/data2',
                        success: function (data) {
                            console.log(data);
                        }
                    });
                }
            });
        }
    });
</pre>
<p>
当嵌套的层数过多时，便会形成“回调地狱”的问题，可读性非常差，因此ES6引入了Promise API。
</p>
<h3>
2.Promise的使用
</h3>
<p>
前面已经简单描述了什么是异步编程和回调地狱，Promise就是为了解决回调地狱的问题而诞生的，Promise的特性如下:
<ul>
<li>主要解决异步深层嵌套的问题</li>
<li>Promise提供了简洁的API使得异步操作更加容易</li>
</ul>
</p>
<p>
Promise的基本使用
<pre>
var p = new Promise(function (resolve, reject) {
        //  这里用于实现异步任务
        setTimeout(function () {
            var flag = false;
            if(flag) {
                //  正常情况
                resolve('hello');
            }else {
                //  异常情况
                reject('出错了')
            }
        }, 100)
    });
    p.then(function (data) {
        console.log(data);
    }).catch(function (info) {
        console.log(info);
    })
</pre>
typeof Promise显示的是function,Promise实际上是个对象,Promise实例创建之后，可以用then方法指定resolved状态和reject状态的回调函数，在后面的then方法可以直接接收数据。
</p>
<p>
基于Promise和原生Ajax可以封装一个函数，发送Ajax请求，代码如下:
<pre>
function queryData(url) {
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if(xhr.readyState != 4) {
                    return
                }
                if(xhr.readyState == 4 && xhr.status == 200) {
                    //  处理正常的情况，直接调用resolve
                    resolve(xhr.responseText);
                }else {
                    reject('服务器错误');
                }
            }
            xhr.open('get', url);
            xhr.send(null);
        });
        // return p;
    }
</pre>
</p>
<p>
需要按照顺序接收Ajax请求，则可以在then方法中直接return一个新的Promise实例，这样就可以按照顺序执行了，代码如下:
<pre>
 queryData('http://localhost:3000/data')
    .then(function (data) {
        console.log(data);
        return queryData('http://localhost:3000/data1')
    })
    .then(function (data) {
        console.log(data);
        return queryData('http://localhost:3000/data2')
    }).catch(function (info) {
        console.log(info);
        return queryData('http://localhost:3000/data2')
    })
    .then(function (data) {
        console.log(data);
    })
</pre>
</p>
<p>
如果then函数中返回的是一个一般值，则会自动被封装成一个Promise对象返回出去，代码如下:
<pre>
queryData('http://localhost:3000/data')
    .then(function (data) {
        return queryData('http://localhost:3000/data1')
    })
    .then(function (data) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                resolve(123);
                // return 1
            }, 1000)
        })
    })
    .then(function (data) {
        console.log(data);
        return 'hello';
    })
    .then(function (data) {
        console.log(data);
    })
</pre>
</p>
<p>
Promise的方法分为对象方法和实例方法，实例方法有三个，除了前面用过的then和catch，还有finally，三种方法的作用如下:
<ul>
<li>
.then()
<br>得到异步任务正确的结果
</li>
<li>
.catch()
<br>获取异常信息
</li>
<li>
.finally()
<br>成功与否都会执行(不是正式标准，但是最新的Chrome浏览器已经实现)
</li>
</ul>
</p>
<p>
演示代码如下:
<pre>
 //  Promise常用API
    function foo() {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                // resolve(123);
                reject('error');
            }, 1000)
        })
    }
    // foo().then(function (data) {
    //     console.log(data);
    // })
    // .catch(function (data) {
    //     console.log(data);
    // })
    // .finally(function () {
    //     console.log('finished');
    // });
    foo().then(function (data) {
        console.log(data);
    }, function (data) {
        console.log(data);
    })
        .finally(function () {
            console.log('finished');
        });
</pre>
其中then可以放两个参数，第一个接收resolve，第二个接收reject;
</p>
<p>
Promise的静态方法有两个，作用如下:
<ul>
<li>
.all()
<br>
Promise.all方法接受一个数组作参数，数组中的对象(p1, p2, p3)均为Promise实例(如果不是一个promise,该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定
</li>
<li>
.race()
<br>
Promise.race方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected), p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。
</li>
</ul>
</p>
<p>
代码如下:
<pre>
 //  Promise的对象方法
    function queryData(url) {
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if(xhr.readyState != 4) return;
                if(xhr.readyState == 4 && xhr.status == 200) {
                    //  处理正常的情况
                    resolve(xhr.responseText);
                }else {
                    //  处理异常的情况
                    reject('服务器错误');
                }
            };
            xhr.open('get', url);
            xhr.send(null);
        });
    }
    var p1 = queryData('http://localhost:3000/a1');
    var p2 = queryData('http://localhost:3000/a2');
    var p3 = queryData('http://localhost:3000/a3');
    // Promise.all([p1, p2, p3]).then(function (result) {
    //     console.log(result);
    // })
    Promise.race([p1, p2, p3]).then(function (result) {
        console.log(result);
    })
</pre>
以上代码中,all()方法会等三个Ajax请求全部完成后再打印结果，而race()方法在第一个Ajax请求完成后就打印。
</p>
